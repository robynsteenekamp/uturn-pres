---
title: "Recommendations and Analytics to Uturn Ministries"
author: "Robyn Steenekamp"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,warning = FALSE, error = FALSE, message = FALSE, cache = TRUE)

```

<!--Multiplot function - reference code from R cookbook-->
```{r multiplot, eval = TRUE}
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

<!-- Import libraries and load data  -->
```{r import, eval = TRUE}

library("rmarkdown")
library("plyr")
library("tidyverse")
library("DT")
library("reshape2")
library("knitr")
library("lubridate")
library("VennDiagram")
library("plotly")
library("grid")
library("RColorBrewer")
library("randomForest")
library("zoo")
library("cluster")
library("kableExtra")
library("parallel")
library("foreach")
library("doParallel")
library("heatmaply")
library("visdat")

clientcsv<-read.csv("data/client.csv")
instancecsv<-read.csv("data/instance.csv")
locationcsv<-read.csv("data/location.csv")
client <- clientcsv[,-1]%>%filter(!is.na(CLIENT_ID))
instance <- instancecsv[,-1]%>%filter(!is.na(CLIENT_ID))
location<-locationcsv[,-1]
```

<!-- BEFORE SUBSETS  -->
```{r before_sub, eval = TRUE}
#return client details with no instance entries (734)
anti_client_full1<-na.omit(anti_join(client, instance,by="CLIENT_ID")%>%distinct(CLIENT_ID))
#return client IDs from instance entries not in client (816)
anti_client_full<-na.omit(anti_join(instance, client,by="CLIENT_ID")%>%distinct(CLIENT_ID))

#add clients in anticlient semijoin
#ie add client IDs from instance entries not in client (816)
anti_client_full_v<-paste(anti_client_full$CLIENT_ID)
client<-client%>%tibble::add_row(CLIENT_ID=anti_client_full_v)
client_full<-semi_join(client,instance,"CLIENT_ID")
instance_full <- instance

#these clients accounted for a total of dim(anti_inst)[[1]] activities.
anti_inst<- instance_full %>% dplyr::filter(CLIENT_ID %in% anti_client_full_v)

# c1 <- client_full %>% distinct(CLIENT_ID)
# c2 <- instance_full %>% distinct(CLIENT_ID)

#reset factor levels for dplyr set operations
client_full$CLIENT_ID <-factor(client_full$CLIENT_ID)
instance_full$CLIENT_ID <-factor(instance_full$CLIENT_ID)
instance_full$S1<-factor(instance_full$SP_MOTIVATION)
instance_full$S2<-factor(instance_full$CHARITY_CLASS_1)
instance_full$S3<-factor(instance_full$CLASS3)
instance_full$START_DATE<-as.Date(as.character(instance_full$START_DATE),'%Y-%m-%d')
instance_full$END_PROG_DATE<-as.Date(as.character(instance_full$END_PROG_DATE),'%Y-%m-%d')
instance_full$START_PROG_DATE<-as.Date(as.character(instance$START_PROG_DATE),'%Y-%m-%d')
instance_full$FA_REPORT_END_DATE<-as.Date(as.character(instance_full$FA_REPORT_END_DATE),'%Y-%m-%d')
instance_full$START_SERV_DATE<-as.Date(as.character(instance_full$START_SERV_DATE),'%Y-%m-%d')


#create invidivual relations for services, programs and focus area reports
service_full <- instance_full %>% filter(SA_IND==1) %>% select(CLIENT_ID, SI_ID,START_DATE, YEAR, LOCATION, NUMBER_OF_ATTENDEES,SERVICE_PRODUCT,TOTAL_VOUCHERS_REDEEMED,NUMBER_OF_VOLUNTEERS,TOTAL_SPONSORED_VOUCHERS, TOTAL_VOUCHERS_FOR_SERV_INST,PRODUCT_NAME,S1,S2,S3)
program_full <- instance_full %>% filter(PA_IND==1) %>% select(CLIENT_ID, PA_ID,PROGRAM_ID,PROG_NAME, YEAR, START_PROG_DATE,END_PROG_DATE,DURATION,REASON_FOR_LEAVING,DURATION_SINCE_GRADUATION)
focus_full <- instance_full %>% filter(FA_IND==1)%>% select(CLIENT_ID, FA_ID,START_DATE,YEAR,EVALUATION_STAGE,FAITH,MONEY_MANAGEMENT,MONEY_MANAGEMENT, ADDICTION, LANGUAGE_AND_LITERACY,VOCATIONAL_SKILLS,EMPLOYMENT,HEALTH_BEHAVIOUR,ACCOMMODATION,COMMUNICATION,GOAL_SETTING,EDUCATION,HOME_AFFAIRS,FAMILY,CELL,DEBT,DRIVERS_LICENSE,SUPPORT_NETWORK,EMOTIONAL_CONTROL,LOCUS_OF_CONTROL,MOTIVATION_FOR_CHANGE,IT_LITERACY,CRIMINAL_RECORD,INST_TYPE)

client_names_full <- client %>% dplyr::distinct(CLIENT_ID)
rm(list=c("clientcsv","locationcsv","instancecsv","anti_client_full_v"))

```
<!-- Commonly used variables and dataframes -->
```{r before_sub_var, eval = TRUE}
# create CUMN table
cumn_df_full <- instance_full %>% group_by(CLIENT_ID) %>% arrange(CLIENT_ID, START_DATE) %>% dplyr::summarise(CUMN = n())
# Last seen
last_seen_date <- instance_full %>% group_by(CLIENT_ID) %>% dplyr::summarise(last_seen_date=max(as.Date(START_DATE,"%Y-%m-%d")))
last_seen_full <- last_seen_date %>% dplyr::mutate(last_seen_days=as.numeric(Sys.Date()-last_seen_date))
# First seen
first_seen_date <- instance_full %>% group_by(CLIENT_ID) %>% arrange(CLIENT_ID, START_DATE) %>% dplyr::summarise(first_seen_date=min(as.Date(START_DATE,"%Y-%m-%d")))
first_seen_full <- first_seen_date %>% dplyr::mutate(first_seen_days=as.numeric(Sys.Date()-first_seen_date))
# CLIENT_INFO - 1 obs per client
t0<- left_join(client_full,first_seen_full[,-3],by="CLIENT_ID")
t1 <- left_join(t0,last_seen_full[,-3],by="CLIENT_ID")
t2 <- left_join(t1,cumn_df_full,by="CLIENT_ID")
cut_date <- as.Date("2016-12-01", "%Y-%m-%d")
client_info_full <- t2 %>% dplyr::mutate(ACTIVE=ifelse(last_seen_date < cut_date, 0, 1),ACTIVE_PERIOD=ifelse(ACTIVE==1,(Sys.Date()-first_seen_date+1)/30,(last_seen_date-first_seen_date+1)/30), END_MONTH=ceiling(ACTIVE_PERIOD)+1)%>%select(CLIENT_ID,CUMN,ACTIVE,ACTIVE_PERIOD,END_MONTH)

rm(list=c("first_seen_date","last_seen_date","t0","t1","t2"))
```

<!-- AFTER SUBSETS  -->
```{r after_sub, eval = TRUE}

#client data has now changed
cumn_df <- cumn_df_full %>% filter(as.numeric(CUMN)>=2)
client_names <- cumn_df$CLIENT_ID
t1 <- cumn_df_full %>% filter(as.numeric(CUMN)<2)

client_control_names <- t1$CLIENT_ID
client_control <- client_full%>%dplyr::filter(CLIENT_ID %in% client_control_names)
instance <- instance_full%>%dplyr::filter(CLIENT_ID %in% client_names)
client <- client_full%>%dplyr::filter(CLIENT_ID %in% client_names)

#return client details with no instance entries (734)
anti_client<-anti_join(client, instance,by="CLIENT_ID")%>%distinct(CLIENT_ID)
#return client IDs from activies not in client (816)
anti_client<-na.omit(anti_join(instance, client,by="CLIENT_ID")%>%distinct(CLIENT_ID))


# c1 <- client %>% distinct(CLIENT_ID)
# c2 <- instance %>% distinct(CLIENT_ID)

#reset factor levels for dplyr set operations
client$CLIENT_ID <-factor(client$CLIENT_ID)
instance$CLIENT_ID <-factor(instance$CLIENT_ID)
instance$S1<-factor(instance$S1)
instance$S2<-factor(instance$S2)
instance$S3<-factor(instance$S3)
instance$START_DATE<-as.Date(as.character(instance$START_DATE),'%Y-%m-%d')
instance$END_PROG_DATE<-as.Date(as.character(instance$END_PROG_DATE),'%Y-%m-%d')
instance$START_PROG_DATE<-as.Date(as.character(instance$START_PROG_DATE),'%Y-%m-%d')
instance$FA_REPORT_END_DATE<-as.Date(as.character(instance$FA_REPORT_END_DATE),'%Y-%m-%d')
instance$START_SERV_DATE<-as.Date(as.character(instance$START_SERV_DATE),'%Y-%m-%d')

#create invidivual relations for services, programs and focus area reports
service <- instance %>% filter(SA_IND==1) %>% select(CLIENT_ID, SI_ID,START_DATE, YEAR, LOCATION, NUMBER_OF_ATTENDEES,SERVICE_PRODUCT,TOTAL_VOUCHERS_REDEEMED,NUMBER_OF_VOLUNTEERS,TOTAL_SPONSORED_VOUCHERS, TOTAL_VOUCHERS_FOR_SERV_INST,PRODUCT_NAME,S1,S2,S3)
program <- instance %>% filter(PA_IND==1) %>% select(CLIENT_ID, PA_ID,PROGRAM_ID,PROG_NAME, YEAR, START_PROG_DATE,END_PROG_DATE,DURATION,REASON_FOR_LEAVING,DURATION_SINCE_GRADUATION)
focus <- instance %>% filter(FA_IND==1)%>% select(CLIENT_ID, FA_ID,START_DATE,YEAR,EVALUATION_STAGE,FAITH,MONEY_MANAGEMENT,MONEY_MANAGEMENT, ADDICTION, LANGUAGE_AND_LITERACY,VOCATIONAL_SKILLS,EMPLOYMENT,HEALTH_BEHAVIOUR,ACCOMMODATION,COMMUNICATION,GOAL_SETTING,EDUCATION,HOME_AFFAIRS,FAMILY,CELL,DEBT,DRIVERS_LICENSE,SUPPORT_NETWORK,EMOTIONAL_CONTROL,LOCUS_OF_CONTROL,MOTIVATION_FOR_CHANGE,IT_LITERACY,CRIMINAL_RECORD,INST_TYPE)

rm(list=c("t1"))
```
<!-- Commonly used variables and dataframes -->
```{r after_sub_var, eval = TRUE}

# Last seen
last_seen_date <- instance %>% group_by(CLIENT_ID) %>% dplyr::summarise(last_seen_date=max(as.Date(START_DATE,"%Y-%m-%d")))
last_seen <- last_seen_date %>% dplyr::mutate(last_seen_days=as.numeric(Sys.Date()-last_seen_date))

# First seen
first_seen_date <- instance %>% group_by(CLIENT_ID) %>% arrange(CLIENT_ID, START_DATE) %>% dplyr::summarise(first_seen_date=min(as.Date(START_DATE,"%Y-%m-%d")))
first_seen <- first_seen_date %>% dplyr::mutate(first_seen_days=as.numeric(Sys.Date()-first_seen_date))

# CLIENT_INFO - 1 obs per client
t0<- left_join(client,first_seen[,-3],by="CLIENT_ID")
t1 <- left_join(t0,last_seen[,-3],by="CLIENT_ID")
t2 <- left_join(t1,cumn_df,by="CLIENT_ID")
cut_date <- as.Date("2016-12-01", "%Y-%m-%d")
client_info <- t2 %>% dplyr::mutate(ACTIVE=ifelse(last_seen_date < cut_date, 0, 1),ACTIVE_PERIOD=ifelse(ACTIVE==1,(Sys.Date()-first_seen_date+1)/30,(last_seen_date-first_seen_date+1)/30), END_MONTH=ceiling(ACTIVE_PERIOD)+1)%>%select(CLIENT_ID,AGE,RACE,GENDER,ACCOMMODATION,NATIONALITY,ACTIVE,ACTIVE_PERIOD,END_MONTH)%>%dplyr::arrange(CLIENT_ID)

rm(list=c("first_seen_date","last_seen_date","t0","t1","t2"))
```

<!-- Create client vars and save in CLIENT_INFO-->
```{r contact_info, eval = TRUE}
C <- client %>% distinct(CLIENT_ID)%>%dplyr::arrange(CLIENT_ID)
S <- service %>% distinct(CLIENT_ID)
nS <- length(S$CLIENT_ID)
FA <- focus %>% distinct(CLIENT_ID)
nFA <- length(FA$CLIENT_ID)
P <- program %>% distinct(CLIENT_ID)
nP <- length(P$CLIENT_ID)

# S FA P 
S.FA<-dplyr::intersect(S, FA); nS.FA <- dim(S.FA)[[1]]
S.P <- dplyr::intersect(S, P); nS.P <- dim(S.P)[[1]]
S.FA.P<-dplyr::intersect(S.FA,P); nS.FA.P<-dim(S.FA.P)[[1]]
FA.P <- dplyr::intersect(FA,P); nFA.P<- dim(FA.P)[[1]]

Q1 = dplyr::intersect(dplyr::intersect(S,dplyr::setdiff(C,P)),dplyr::setdiff(C,FA))
Q2 = dplyr::intersect(P,dplyr::setdiff(C,FA))
Q3 = dplyr::intersect(FA,dplyr::setdiff(C,P))
Q4 = dplyr::intersect(FA,P)

#Code to show that Qi does form a partition of C1
Ctest = dplyr::union(dplyr::union(Q1,Q2),dplyr::union(Q3,Q4))
Ctest = Ctest$CLIENT_ID[order(Ctest$CLIENT_ID)]; C=C$CLIENT_ID[order(C$CLIENT_ID)]
#all(Ctest==C)

#update client info
client_info <- client_info %>% dplyr::mutate(C1=ifelse(CLIENT_ID %in% Q1$CLIENT_ID, 1, ifelse(CLIENT_ID %in% Q2$CLIENT_ID,2, ifelse(CLIENT_ID %in% Q3$CLIENT_ID, 3, ifelse(CLIENT_ID %in% Q3$CLIENT_ID, 4, ifelse(CLIENT_ID %in% Q4$CLIENT_ID, 4,NA))))))

rm(list=c("Ctest","C","Q1","Q2","Q3","Q4"))
```

<!--  in stacked form -->
<!-- Create service vars and save in SERVICE_INFO-->
```{r service_info, eval = TRUE}

s0<- left_join(service,first_seen[,-3],by="CLIENT_ID")

s1 <- s0 %>% group_by(CLIENT_ID) %>% dplyr::arrange(CLIENT_ID,START_DATE)%>% dplyr::mutate(curr=ymd(START_DATE),prev=curr %m-% months(1),nxt=curr %m+% months(1),lg=lag(curr), ld=lead(curr))

s2<-s1 %>% dplyr::mutate(S3=ifelse(curr<=(first_seen_date%m+%months(1)),"NEW",ifelse(prev<=lg,"RETURNING","REACTIVATED")))

s2$S3<-factor(s2$S3)

#service information - longitudinal
s3 <- s2 %>% group_by(CLIENT_ID) %>% dplyr::arrange(CLIENT_ID, START_DATE)%>% dplyr::mutate(I = 1, CUM_SERV=cumsum(I),T1 = as.Date(START_DATE,"%Y-%m-%d")-lag(as.Date(START_DATE,"%Y-%m-%d")))

s3$T1[is.na(s3$T1)] <- 0

#t2 = cumulative days since first seen
s4 <- s3 %>%dplyr::mutate(T2=cumsum(as.numeric(T1)))

s5 <- s4 %>% dplyr::select(CLIENT_ID,SI_ID,START_DATE,PRODUCT_NAME,CUM_SERV,T1,T2,S1,S2,S3)

#days inactive and active
s6 <- s5 %>% dplyr::mutate(T_INACT=ifelse(S3=="REACTIVATED",T1,0),T_ACT=ifelse(S3=="RETURNING",T1,0))

#create dummy variables for S1, S2, S3

s7 <- s6  %>% dplyr::mutate(S1_DUMMY_1=ifelse(S1=="Needs-based",1,0),S1_DUMMY_2=ifelse(S1=="Volition-based",1,0),S1_DUMMY_3=ifelse(S1=="Rehabilitative",1,0),S2_DUMMY_1=ifelse(S2==1,1,0),S2_DUMMY_2=ifelse(S2==2,1,0),S2_DUMMY_3=ifelse(S2==3,1,0),S2_DUMMY_4=ifelse(S2==4,1,0),S3_DUMMY_1=ifelse(S3=="NEW",1,0),S3_DUMMY_2=ifelse(S3=="RETURNING",1,0),S3_DUMMY_3=ifelse(S3=="REACTIVATED",1,0))

#time series by month
seq_month <- seq(from=0, to=110, by=1)

service_info_stack <- s7 %>% dplyr::mutate(T_MONTHS=findInterval(T2/30, seq_month))

rm(list=c("s0","s1","s2","s3","s4","s5","s6","s7"))

```


<!--  in "normal" form -->
<!-- 1 obs per client-->
```{r cast1, eval = TRUE}


MOT1 <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS, value.var="S1_DUMMY_1",sum)%>%arrange(CLIENT_ID)
MOT1_C <- MOT1
MOT1_C[,2:ncol(MOT1_C)] <- t(apply(MOT1_C[,2:ncol(MOT1_C)],1,cumsum))

MOT2 <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS, value.var="S1_DUMMY_2",sum)%>%arrange(CLIENT_ID)
MOT2_C <- MOT2
MOT2_C[,2:ncol(MOT2_C)] <- t(apply(MOT2_C[,2:ncol(MOT2_C)],1,cumsum))

MOT3 <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS, value.var="S1_DUMMY_3",sum)%>%arrange(CLIENT_ID)
MOT3_C <- MOT3
MOT3_C[,2:ncol(MOT3_C)] <- t(apply(MOT3_C[,2:ncol(MOT3_C)],1,cumsum))

PH1 <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS,sum, value.var="S2_DUMMY_1")%>%arrange(CLIENT_ID)
PH1_C <- PH1
PH1_C[,2:ncol(PH1_C)] <- t(apply(PH1_C[,2:ncol(PH1_C)],1,cumsum))

PH2 <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS,sum, value.var="S2_DUMMY_2")%>%arrange(CLIENT_ID)
PH2_C <- PH2
PH2_C[,2:ncol(PH2_C)] <- t(apply(PH2_C[,2:ncol(PH2_C)],1,cumsum))

PH3 <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS,sum, value.var="S2_DUMMY_3")%>%arrange(CLIENT_ID)
PH3_C <- PH3
PH3_C[,2:ncol(PH3_C)] <- t(apply(PH3_C[,2:ncol(PH3_C)],1,cumsum))

PH4 <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS,sum, value.var="S2_DUMMY_4")%>%arrange(CLIENT_ID)
PH4_C <- PH4
PH4_C[,2:ncol(PH4_C)] <- t(apply(PH4_C[,2:ncol(PH4_C)],1,cumsum))

C_CUMN <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS, value.var="CUM_SERV",sum)%>%arrange(CLIENT_ID)

NEW <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS, value.var="S3_DUMMY_1",sum)%>%arrange(CLIENT_ID)
NEW_C <- NEW
NEW_C[,2:ncol(NEW_C)] <- t(apply(NEW_C[,2:ncol(NEW_C)],1,cumsum))

RET <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS, value.var="S3_DUMMY_2",sum)%>%arrange(CLIENT_ID)
RET_C <- RET
RET_C[,2:ncol(RET_C)] <- t(apply(RET_C[,2:ncol(RET_C)],1,cumsum))

REACT <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS, value.var="S3_DUMMY_3",sum)%>%arrange(CLIENT_ID)
REACT_C <- REACT
REACT_C[,2:ncol(REACT_C)] <- t(apply(REACT_C[,2:ncol(REACT_C)],1,cumsum))

INACT <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS, value.var="T_INACT",sum)%>%arrange(CLIENT_ID)
INACT_C <- INACT
INACT_C[,2:ncol(INACT_C)] <- t(apply(INACT_C[,2:ncol(INACT_C)],1,cumsum))

ACT <- dcast(service_info_stack, CLIENT_ID ~ T_MONTHS, value.var="T_ACT",sum)%>%arrange(CLIENT_ID)
ACT_C <- ACT
ACT_C[,2:ncol(ACT_C)] <- t(apply(ACT_C[,2:ncol(ACT_C)],1,cumsum))



```


```{r eval = TRUE}

temp <- client_info%>%dplyr::mutate(END_MONTH=ifelse(END_MONTH>98,98,END_MONTH))%>%dplyr::arrange(CLIENT_ID)


cl <- makeCluster(3)
registerDoParallel(cl)


zz <- foreach(c_name = temp$CLIENT_ID,.combine=rbind,.packages=c("dplyr")) %dopar%{
  temp2 <- temp %>% filter(CLIENT_ID==c_name) 
  ind_vec <- seq(from=temp2$END_MONTH,to=99)
  i<-which(client_info$CLIENT_ID == c_name)
  MOT1[i,ind_vec] <- NA
  MOT2[i,ind_vec] <- NA
  MOT3[i,ind_vec] <- NA
  PH1[i,ind_vec] <- NA
  PH2[i,ind_vec] <- NA
  PH3[i,ind_vec] <- NA
  PH4[i,ind_vec] <- NA
  C_CUMN[i,ind_vec] <- NA
  INACT[i,ind_vec] <- NA
  ACT[i,ind_vec] <- NA
  REACT[i,ind_vec] <- NA
  RET[i,ind_vec] <- NA
  NEW[i,ind_vec] <- NA
  MOT1_C[i,ind_vec] <- NA
  MOT2_C[i,ind_vec] <- NA
  MOT3_C[i,ind_vec] <- NA
  PH1_C[i,ind_vec] <- NA
  PH2_C[i,ind_vec] <- NA
  PH3_C[i,ind_vec] <- NA
  PH4_C[i,ind_vec] <- NA
  INACT_C[i,ind_vec] <- NA
  ACT_C[i,ind_vec] <- NA
  REACT_C[i,ind_vec] <- NA
  RET_C[i,ind_vec] <- NA
  NEW_C[i,ind_vec] <- NA
}

stopCluster(cl)
rm(list=c("zz","i","ii","cl","temp"))
#save.image("Present_12Nov.RData")

```


# Introduction




# Research questions

1. **Duration sensitivity: ** how long a particular client visits the service centre before transitioning from needs-based services to volition-based or rehabilitative services. 
2. **Frequency sensitivity: ** how many times a client is seen before they transistion from needs-based services to volition-based or rehabilitative services.
3. **Effect of age: **Is there is difference in long-term outcomes for older clients versus younger clients?
4. **Effect of gender: **Is there is difference in long-term outcomes for males and females.
5. Ultimately can we discern causality of long term success from the data?


# Data

After cleaning data: `r dim(instance_full)[[1]]` activity entries from `r dim(client_full)[[1]]` clients. 

NOTE:

1. There are `r dim(anti_client_full1)[[1]]` clients in the database with no record of attending U-turn activities. 

2. There are `r dim(anti_inst)[[1]]` activity entries from `r dim(anti_client_full)[[1]]` clients who are not in the database - suggested that this could be from old U-turn clients who are now staff members and therefore do not have a `client_id`.

## Clients
<!-- compare client_control with client ito missing data and demographics-->
Because of such a high instance of once-off clients we restrict the client space to include only those who have records of two or more activities. The remaining "once-off" clients are used as controls.

```{r update_ci, eval = TRUE}

client_info_full <- client_info_full %>% dplyr::mutate(TREAT=ifelse(CLIENT_ID%in%client_names,1,ifelse(CLIENT_ID%in%client_control_names,0,NA))

```


Hierarchical clustering (mcquitty method) to arrange rows according to missingness.


```{r dat_vis1, eval = TRUE}

vis_miss(client, cluster=TRUE, sort_miss =TRUE)
client_sub1 <- client %>%dplyr::select(CLIENT_ID, GENDER, RACE, AGE)
client_sub1 <- na.omit(client_sub1)
client_names_sub1 <- client_sub1$CLIENT_ID
instance_sub1 <- instance %>% dplyr::filter(CLIENT_ID %in% client_names_sub1)

```

`r length(client_names_sub1)` U-turn clients remain with complete demographic information. These clients collectively had `r dim(instance_sub1)[[1]]` U-turn records.

Took the following into consideration:

1. Activity type
2. Duration of activity
3. Frequency of activity


### C1 - Activity type

Let C = {All U-turn clients}. The following subsets of C exist:

* S = {U-turn clients who have accessed *at least 2* service products}
* P = {U-turn clients who have attended either Addiction rehab or Life Change programs}
* FA = {U-turn clients who have Focus Area reports}


```{r venn, eval = TRUE}
# Venn diagram S FA P
venn.plot0 <- draw.triple.venn(area1 = nS,area2 = nFA,area3 = nP,n12 = nS.FA,n23=nFA.P,n13=nS.P,n123=nS.FA.P,category = c("S", "FA","P"),fill = c("blue", "red", "green"),rotation=3,lty = "blank",cex = 2,
cat.cex = 2,cat.col = c("blue", "red", "green"),euler.d = TRUE,scaled=FALSE)
grid.newpage()

Q1<-client_info%>%filter(C1==1)
Q2<-client_info%>%filter(C1==2)
Q3<-client_info%>%filter(C1==3)
Q4<-client_info%>%filter(C1==4)

rm(list=c("nFA","nFA.P","nP","nS","nS.FA","nS.FA.P","nS.P","P","S.FA","S.FA.P","S.P","FA","FA.P"))

```

Clients are partitioned into unequally sized mutually exclusive subsets.

* Q1 = S and not(P) and not(FA)
* Q2 = S and not(P) and FA
* Q3 = S and P and not(FA)
* Q4 = S and P and FA

```{r part, eval = TRUE}
prop.table(table(client_info$C1))
```



### C2 - Service activity duration



```{r act_period, eval = FALSE}

x <- list(title = "Total active period (in months)")
y <- list(title = "Frequency")

temp <- client_info 
p1 <- plot_ly(alpha = 0.6) %>%
  add_histogram(x = ~temp$END_MONTH) %>%
  layout(xaxis=x,yaxis=y)
p1

rm(list=c("temp","x","y","p1"))

Q1<-client_info%>%filter(C1==1)
Q2<-client_info%>%filter(C1==2)
Q3<-client_info%>%filter(C1==3)
Q4<-client_info%>%filter(C1==4)

AP_1 <- client_info %>% filter(CLIENT_ID %in% Q1$CLIENT_ID)
AP_2 <- client_info %>% filter(CLIENT_ID %in% Q2$CLIENT_ID)
AP_3 <- client_info %>% filter(CLIENT_ID %in% Q3$CLIENT_ID)
AP_4 <- client_info %>% filter(CLIENT_ID %in% Q4$CLIENT_ID)

p <- plot_ly(y=~AP_1$END_MONTH, alpha=0.5,type="box",name="Q1")%>%
  add_trace(y =~AP_2$END_MONTH,name="Q2")%>%
  add_trace(y =~AP_3$END_MONTH,name="Q3")%>%
  add_trace(y =~AP_4$END_MONTH,name="Q4")%>%
  layout(xaxis=list(title="Partition"),yaxis=list(title="Active period (in months)"))

p

client_info <- client_info %>% dplyr::mutate(C1=ifelse(C1==1,ifelse(END_MONTH>=64,1,0),C1))

Q0<-client_info%>%filter(C1==0)
Q1<-client_info%>%filter(C1==1)
Q2<-client_info%>%filter(C1==2)
Q3<-client_info%>%filter(C1==3)
Q4<-client_info%>%filter(C1==4)

AP_0 <- client_info %>% filter(CLIENT_ID %in% Q0$CLIENT_ID)
AP_1 <- client_info %>% filter(CLIENT_ID %in% Q1$CLIENT_ID)
AP_2 <- client_info %>% filter(CLIENT_ID %in% Q2$CLIENT_ID)
AP_3 <- client_info %>% filter(CLIENT_ID %in% Q3$CLIENT_ID)
AP_4 <- client_info %>% filter(CLIENT_ID %in% Q4$CLIENT_ID)

p <- plot_ly(y=~AP_0$END_MONTH, alpha=0.5,type="box",name="Q0")%>%
  add_trace(y =~AP_1$END_MONTH,name="Q1")%>%
  add_trace(y =~AP_2$END_MONTH,name="Q2")%>%
  add_trace(y =~AP_3$END_MONTH,name="Q3")%>%
  add_trace(y =~AP_4$END_MONTH,name="Q4")%>%
  layout(xaxis=list(title="Partition"),yaxis=list(title="Active period (in months)"))

p

```

### C3 - Service activity frequency


```{r serv_hist_20, eval = FALSE}

x <- list(title = "Number of services accessed")
y <- list(title = "Frequency")

temp <- cumn_df_full %>% filter(as.numeric(CUMN) <= 20)
p1 <- plot_ly(alpha = 0.6) %>%
  add_histogram(x = ~temp$CUMN) %>%
  layout(xaxis=x,yaxis=y)
p1

rm(list=c("temp","x","y","p1"))
```

```{r serv_hist, eval = FALSE}

x <- list(title = "Number of services accessed")
y <- list(title = "Frequency")

temp <- cumn_df
p1 <- plot_ly(alpha = 0.6) %>%
  add_histogram(x = ~temp$CUMN) %>%
  layout(xaxis=x,yaxis=y)
p1

rm(list=c("temp","x","y","p1"))
```

```{r cum_box, eval = FALSE}
C_0 <- cumn_df %>% filter(CLIENT_ID %in% Q0$CLIENT_ID) %>% select(CUMN)
C_1 <- cumn_df %>% filter(CLIENT_ID %in% Q1$CLIENT_ID) %>% select(CUMN)
C_2 <- cumn_df %>% filter(CLIENT_ID %in% Q2$CLIENT_ID)%>% select(CUMN)
C_3 <- cumn_df %>% filter(CLIENT_ID %in% Q3$CLIENT_ID)%>% select(CUMN)
C_4 <- cumn_df %>% filter(CLIENT_ID %in% Q4$CLIENT_ID)%>% select(CUMN)

p <- plot_ly(y=~C_0$CUMN, alpha=0.5,type="box",name="Q0")%>%
  add_trace(y =~C_1$CUMN,name="Q1")%>%
  add_trace(y =~C_2$CUMN,name="Q2")%>%
  add_trace(y =~C_3$CUMN,name="Q3")%>%
  add_trace(y =~C_4$CUMN,name="Q4")%>%
  layout(xaxis=list(title="Partition"),yaxis=list(title="Total number of services accessed"))

p

rm(list=c("AP_1","AP_2","AP_3","AP_4"))
```


### Notes
- heat matrix for correlation of vars


## Services

A breakdown of service types is shown below. Life

### S1 - Service product motivation

Basic-needs, volition, rehabilitative
    
### S2 - Phase 

I, II, III, IV
    
### S3 - Status

Activities of Daily Living, Housing, Education, Employment, Motivation and Relationships, Community connectivity, Self-Efficacy, Legal, Medical, Mental Health, Substances, Financial

### S4 - Points of service

### Notes

<!-- <!-- Service data in wide / stacked form -->
<!-- ```{r eval = T, warning = F, error = F, message = F, cache = T} -->
<!-- knitr::kable(temp1[1:10,]) -->
<!-- ``` -->
<!-- ### Basic needs dataframe -->
<!-- ```{r eval = T, warning = F, error = F, message = F, cache = T} -->
<!-- knitr::kable(MOT1[1:10,]) -->
<!-- ``` -->
<!-- ### Time series - split by SP motivation -->
<!-- ```{r eval = T, echo = F, warning = F, error = F, message = F, cache = T} -->
<!-- samp_c_list <- list("0031300002KBs04AAD","003a000001SXg0ZAAT","0033000001AkZ6YAAV") -->
<!-- p_list = list() -->
<!-- i=1 -->
<!-- for (samp_c in samp_c_list) -->
<!-- { -->
<!--   m1 <- MOT1_C %>% filter(CLIENT_ID == samp_c) -->
<!--   M1 <- m1[,-1] -->
<!--   m2 <- MOT2_C %>% filter(CLIENT_ID == samp_c) -->
<!--   M2 <- m2[,-1] -->
<!--   m3 <- MOT3_C %>% filter(CLIENT_ID == samp_c) -->
<!--   M3 <- m3[,-1] -->
<!--   time<-1:98 -->
<!--   df<-data.frame(time, t(rbind(M1,M2,M3))) -->
<!--   t_end <- CLIENT_INFO %>% filter(CLIENT_ID == samp_c) -->
<!--   t_end <- ceiling(t_end$ACTIVE_PERIOD)+4 -->
<!--   p<- plot_ly(df, x=~time, y=~X1, name="Motivation 1",type="scatter",mode="lines+markers")%>% -->
<!--     add_trace(y=~X2,name="Motivation 2",mode="lines+markers")%>% -->
<!--     add_trace(y=~X3,name="Motivation 3",mode="lines+markers")%>% -->
<!--     layout(xaxis=list(range=c(0,t_end),title="Time (months since first contact)"),yaxis=list(title="Frequency")) -->
<!--   p_list[[i]]=p -->
<!--   i=i+1 -->
<!-- } -->


<!-- p_list[[1]]#;p_list[[2]];p_list[[3]] -->

<!-- rm(list=c("m1","m2","m3","M1","M2","M3","i","p_list")) -->

<!-- ``` -->

<!-- ### Averages -->
<!-- ```{r eval = T, echo = F, warning = F, error = F, message = F, cache = T} -->

<!-- ACT_df <- ACT[,1:2] -->
<!-- ACT_df[,2] <- apply(ACT[,2:ncol(ACT)],1,mean,na.rm=TRUE) -->
<!-- ACT_df <- data.frame("CLIENT_ID"=ACT_df[,1],"y"=ACT_df[,2]) -->


<!-- MOT1_df <- MOT1[,1:2] -->
<!-- MOT1_df[,2] <- apply(MOT1[,2:ncol(MOT1)],1,mean,na.rm=TRUE) -->
<!-- MOT1_df <- data.frame("CLIENT_ID"=MOT1_df[,1],"y"=MOT1_df[,2]) -->

<!-- MOT2_df <- MOT2[,1:2] -->
<!-- MOT2_df[,2] <- apply(MOT2[,2:ncol(MOT2)],1,mean,na.rm=TRUE) -->
<!-- MOT2_df <- data.frame("CLIENT_ID"=MOT2_df[,1],"y"=MOT2_df[,2]) -->

<!-- MOT3_df <- MOT3[,1:2] -->
<!-- MOT3_df[,2] <- apply(MOT3[,2:ncol(MOT3)],1,mean,na.rm=TRUE) -->
<!-- MOT3_df <- data.frame("CLIENT_ID"=MOT3_df[,1],"y"=MOT3_df[,2]) -->
<!-- ``` -->

<!-- ```{r eval = T, warning = F, error = F, message = F, cache = T} -->

<!-- AP_1 <- ACT_df %>% filter(CLIENT_ID %in% Q1$CLIENT_ID) %>% select(y) -->
<!-- AP_2 <- ACT_df %>% filter(CLIENT_ID %in% Q2$CLIENT_ID)%>% select(y) -->
<!-- AP_3 <- ACT_df %>% filter(CLIENT_ID %in% Q3$CLIENT_ID)%>% select(y) -->
<!-- AP_4 <- ACT_df %>% filter(CLIENT_ID %in% Q4$CLIENT_ID)%>% select(y) -->

<!-- p <- plot_ly(y=~AP_1$y, alpha=0.5,type="box",name="Q1")%>% -->
<!--   add_trace(y =~AP_2$y,name="Q2")%>% -->
<!--   add_trace(y =~AP_3$y,name="Q3")%>% -->
<!--   add_trace(y =~AP_4$y,name="Q4")%>% -->
<!--   layout(xaxis=list(title="Partition"),yaxis=list(title="Average length of active periods (days)")) -->

<!-- p -->

<!-- rm(list=c("AP_1","AP_2","AP_3","AP_4")) -->
<!-- ``` -->

<!-- ```{r eval = T, warning = F, error = F, message = F, cache = T} -->

<!-- AP_1 <- ACT_df %>% filter(CLIENT_ID %in% Q1$CLIENT_ID) %>% select(y) -->
<!-- AP_2 <- ACT_df %>% filter(CLIENT_ID %in% Q2$CLIENT_ID)%>% select(y) -->
<!-- AP_3 <- ACT_df %>% filter(CLIENT_ID %in% Q3$CLIENT_ID)%>% select(y) -->
<!-- AP_4 <- ACT_df %>% filter(CLIENT_ID %in% Q4$CLIENT_ID)%>% select(y) -->

<!-- p <- plot_ly(y=~AP_1$y, alpha=0.5,type="box",name="Q1")%>% -->
<!--   add_trace(y =~AP_2$y,name="Q2")%>% -->
<!--   add_trace(y =~AP_3$y,name="Q3")%>% -->
<!--   add_trace(y =~AP_4$y,name="Q4")%>% -->
<!--   layout(xaxis=list(title="Partition"),yaxis=list(title="Average length of active periods (days)")) -->

<!-- p -->

<!-- rm(list=c("AP_1","AP_2","AP_3","AP_4")) -->
<!-- ``` -->

<!-- ```{r eval = T, warning = F, error = F, message = F, cache = T} -->

<!-- AP_1 <- MOT1_df %>% filter(CLIENT_ID %in% Q1$CLIENT_ID) %>% select(y) -->
<!-- AP_2 <- MOT1_df %>% filter(CLIENT_ID %in% Q2$CLIENT_ID)%>% select(y) -->
<!-- AP_3 <- MOT1_df %>% filter(CLIENT_ID %in% Q3$CLIENT_ID)%>% select(y) -->
<!-- AP_4 <- MOT1_df %>% filter(CLIENT_ID %in% Q4$CLIENT_ID)%>% select(y) -->

<!-- p <- plot_ly(y=~AP_1$y, alpha=0.5,type="box",name="Q1")%>% -->
<!--   add_trace(y =~AP_2$y,name="Q2")%>% -->
<!--   add_trace(y =~AP_3$y,name="Q3")%>% -->
<!--   add_trace(y =~AP_4$y,name="Q4")%>% -->
<!--   layout(xaxis=list(title="Partition"),yaxis=list(title="Total count of basic needs services accessed")) -->

<!-- p -->

<!-- rm(list=c("AP_1","AP_2","AP_3","AP_4")) -->
<!-- ``` -->

<!-- ```{r eval = T, warning = F, error = F, message = F, cache = T} -->

<!-- AP_1 <- MOT2_df %>% filter(CLIENT_ID %in% Q1$CLIENT_ID) %>% select(y) -->
<!-- AP_2 <- MOT2_df %>% filter(CLIENT_ID %in% Q2$CLIENT_ID)%>% select(y) -->
<!-- AP_3 <- MOT2_df %>% filter(CLIENT_ID %in% Q3$CLIENT_ID)%>% select(y) -->
<!-- AP_4 <- MOT2_df %>% filter(CLIENT_ID %in% Q4$CLIENT_ID)%>% select(y) -->

<!-- p <- plot_ly(y=~AP_1$y, alpha=0.5,type="box",name="Q1")%>% -->
<!--   add_trace(y =~AP_2$y,name="Q2")%>% -->
<!--   add_trace(y =~AP_3$y,name="Q3")%>% -->
<!--   add_trace(y =~AP_4$y,name="Q4")%>% -->
<!--   layout(xaxis=list(title="Partition"),yaxis=list(title="Total MOT2 services accessed")) -->

<!-- p -->

<!-- rm(list=c("AP_1","AP_2","AP_3","AP_4")) -->
<!-- ``` -->

<!-- ```{r eval = T, warning = F, error = F, message = F, cache = T} -->
<!-- AP_1 <- MOT3_df %>% filter(CLIENT_ID %in% Q1$CLIENT_ID) %>% select(y) -->
<!-- AP_2 <- MOT3_df %>% filter(CLIENT_ID %in% Q2$CLIENT_ID)%>% select(y) -->
<!-- AP_3 <- MOT3_df %>% filter(CLIENT_ID %in% Q3$CLIENT_ID)%>% select(y) -->
<!-- AP_4 <- MOT3_df %>% filter(CLIENT_ID %in% Q4$CLIENT_ID)%>% select(y) -->

<!-- p <- plot_ly(y=~AP_1$y, alpha=0.5,type="box",name="Q1")%>% -->
<!--   add_trace(y =~AP_2$y,name="Q2")%>% -->
<!--   add_trace(y =~AP_3$y,name="Q3")%>% -->
<!--   add_trace(y =~AP_4$y,name="Q4")%>% -->
<!--   layout(xaxis=list(title="Partition"),yaxis=list(title="Total MOT3 services accessed")) -->

<!-- p -->

<!-- rm(list=c("AP_1","AP_2","AP_3","AP_4")) -->
<!-- ``` -->

<!-- -->


## Program

### P1 - Rehabilitation level

Using information from the **service** and **program** relations I created a hierarchical scoring system for monitoring clients' rehabilitation.

- **1: Follow up**
    + Service activity where PRODUCT_NAME == "P3 Follow-up Meeting"
    
- **2: Accommodation hunting**
    + Service activity where PRODUCT_NAME == "P3 Accommodation Hunting"

- **3: Graduated from Life Change**
    + Service activity where PRODUCT_NAME == "P2 Exit Interview" 
    + Program entry for Life Change where REASON_FOR_LEAVING == "Graduation Exit"

- **4: Entry to Life Change**
    + Program entry for Life Change where REASON_FOR_LEAVING == "Still enrolled in program"
    
- **5: Referred to Life Change**
    + Service activity where PRODUCT_NAME == "P1 Referral to Life Change"

- **6: Graduated from Addiction Rehab**
    + Service activity where PRODUCT_NAME == "P1 1/2 Addiction rehab graduation" 
    + Program entry for Addiction Rehab where REASON_FOR_LEAVING == "Graduation Exit"

- **7: Entry to Addiction Rehab**
    + Program entry for Addiction Rehab where REASON_FOR_LEAVING == "Still enrolled in program"

- **8: Referral to Addiction Rehab**
    + Service activity where PRODUCT_NAME == "P2 Referral to 1st Phase"
    + Service activity where PRODUCT_NAME == "P1 Referral to Addiction Rehab"

- **0: Relapse**
    + Program entry for Addiction Rehab / Life Change where REASON_FOR_LEAVING == "AWOL" / "Resigned before completion"

- **-1: No engagement in program activities**
    + Before client begins rehabilitative process
    
```{r eval = TRUE}

instance_copy <- instance%>%group_by(CLIENT_ID)%>%arrange(CLIENT_ID,START_DATE) %>% dplyr::mutate(Y3=ifelse(row_number()==1,-1,NA))%>% dplyr::mutate(Y3=ifelse(INST_TYPE==1,ifelse(PRODUCT_NAME=="P1 Referral to Addiction Rehab",8,ifelse(PRODUCT_NAME=="P1 Referral to Life Change",5,ifelse(PRODUCT_NAME=="P2 Referral to 1st Phase",8,ifelse(PRODUCT_NAME=="P1 1/2 Addiction rehab graduation",6,ifelse(PRODUCT_NAME=="P2 Exit Interview",3,ifelse(PRODUCT_NAME=="P3 Accommodation Hunting",2,ifelse(PRODUCT_NAME=="P3 Follow-up Meeting",1,Y3))))))),ifelse(INST_TYPE==2,ifelse(PROG_NAME=="Addiction Rehab",ifelse(REASON_FOR_LEAVING%in%c("AWOL","Resigned before completion"),0,ifelse(REASON_FOR_LEAVING=="Graduation Exit",6,7)),ifelse(REASON_FOR_LEAVING%in%c("AWOL","Resigned before completion"),0,ifelse(REASON_FOR_LEAVING=="Graduation Exit",3,4))),Y3)))%>% dplyr::mutate(Y3=na.locf(Y3))
```


```{r last_stat, eval = TRUE}
last_status<-instance_copy %>% group_by(CLIENT_ID) %>%top_n(1,START_DATE)

last_status_P<-instance_copy %>%filter(CLIENT_ID%in%P$CLIENT_ID)%>% group_by(CLIENT_ID) %>%top_n(1,START_DATE)

table(last_status$Y3)
table(last_status_P$Y3)
```




### P2 - Addicition or not
### Notes






## Correlation matrices:
```{r corr_mat1, eval = TRUE}

temp2 <- temp1 %>% group_by(CLIENT_ID) %>% dplyr::summarise(R1=sum(NEED),R2=sum(VOL),R3=sum(RE),N1=sum(S3_DUMMY_1),N2=sum(S3_DUMMY_2),N3=sum(S3_DUMMY_3),TW=max(T_WEEKS))

d1 <- left_join(temp2,Y1[,c(1,5,6,7,9,17)],by="CLIENT_ID")
corr <- cor(na.omit(d1[vapply(d1, is.numeric, logical(1))]))
p <- plot_ly(x = rownames(corr), y = colnames(corr), z = corr) %>%
  add_heatmap() %>%
  colorbar(limits = c(-1, 1))

corr <- cor(na.omit(temp1[vapply(temp1, is.numeric, logical(1))]))
p <- plot_ly(x = rownames(corr), y = colnames(corr), z = corr) %>%
  add_heatmap() %>%
  colorbar(limits = c(-1, 1))
p

```

## Multi-dimensional scaling
```{r eval = FALSE}

temp3 <- left_join(Y1[,c(1,17)],temp2,by="CLIENT_ID")
x1 <- na.omit(temp3[,-1])
y1 <- na.omit(temp3[,2])
rf1<-randomForest(x=x1,importance=TRUE)
MDSplot(rf1, y1)
MDSplot(rf1, y1,k=3)
```




# Chi squared tests


I have two groups of buyers, A and B, and I want to test whether the difference between the percentage of them who would buy a product is significant.

Group A: 271 out of 2520 bought the product (10.8%) and 2,249 didn't buy.
Group B: 1,073,839 out of 41,873,457 bought the product (2.6%) and 40,799,618 didn't buy.

* Cramer's V (measure of effect size)
    - risk difference: (271/2520) - (1073839/41873457) = 0.08189482
    - risk ratio: (271/2520) / (1073839/41873457) = 4.19342
    - odds ratio: (271/2249) / (1073839/40799618) = 4.578221


# Clustering

Create dummy variables for:


## Daisy

# Multidimensional scaling
Multidimensional scaling (MDS) is a means of visualizing the level of similarity  of individual cases of a dataset. It refers to a set of related ordination techniques used in information visualization, in particular to display the information contained in a distance matrix. 

1. Principal Coordinates Analysis / Classical  multidimensional scaling

2. Metric multidimensional scaling
    + "stress" function
    
There are several steps in conducting MDS research:

1. Formulating the problem – What variables do you want to compare? How many variables do you want to compare? What purpose is the study to be used for?

2. Obtaining input data – For example: Respondents are asked a series of questions. For each product pair, they are asked to rate similarity (usually on a 7-point Likert scale from very similar to very dissimilar). The first question could be for Coke/Pepsi for example, the next for Coke/Hires rootbeer, the next for Pepsi/Dr Pepper, the next for Dr Pepper/Hires rootbeer, etc. The number of questions is a function of the number of brands and can be calculated as {\displaystyle Q=N(N-1)/2} Q=N(N-1)/2 where Q is the number of questions and N is the number of brands. This approach is referred to as the “Perception data : direct approach”. There are two other approaches. There is the “Perception data : derived approach” in which products are decomposed into attributes that are rated on a semantic differential scale. The other is the “Preference data approach” in which respondents are asked their preference rather than similarity.

3. Running the MDS statistical program – Software for running the procedure is available in many statistical software packages. Often there is a choice between Metric MDS (which deals with interval or ratio level data), and Nonmetric MDS[5] (which deals with ordinal data).

4. Decide number of dimensions – The researcher must decide on the number of dimensions they want the computer to create. The more dimensions, the better the statistical fit, but the more difficult it is to interpret the results.

5. Mapping the results and defining the dimensions – The statistical program (or a related module) will map the results. The map will plot each product (usually in two-dimensional space). The proximity of products to each other indicate either how similar they are or how preferred they are, depending on which approach was used. How the dimensions of the embedding actually correspond to dimensions of system behavior, however, are not necessarily obvious. Here, a subjective judgment about the correspondence can be made (see perceptual mapping).

6. Test the results for reliability and validity – Compute R-squared to determine what proportion of variance of the scaled data can be accounted for by the MDS procedure. An R-square of 0.6 is considered the minimum acceptable level.[citation needed] An R-square of 0.8 is considered good for metric scaling and .9 is considered good for non-metric scaling. Other possible tests are Kruskal’s Stress, split data tests, data stability tests (i.e., eliminating one brand), and test-retest reliability.

7. Report the results comprehensively – Along with the mapping, at least distance measure (e.g., Sorenson index, Jaccard index) and reliability (e.g., stress value) should be given. It is also very advisable to give the algorithm (e.g., Kruskal, Mather), which is often defined by the program used (sometimes replacing the algorithm report), if you have given a start configuration or had a random choice, the number of runs, the assessment of dimensionality, the Monte Carlo method results, the number of iterations, the assessment of stability, and the proportional variance of each axis (r-square).


## Correspondece analysis

## Multiple correspondence analysis

## Multiple factor analysis

Multiple Factor Analysis for mixed data available in the FactoMineR R package (AFDM()). If your variables can be considered as structured subsets of descriptive attributes, then Multiple Factor Analysis (MFA()) is also an option.

## Principal component analysis

* Kernel PCA

## Isomaps

## Agnes

## SOM


# Support vector machine
* Unlabeled

# Hello



```{r eval = FALSE}



REF_ADD <- service %>% filter(PRODUCT_NAME=="P1 Referral to Addiction Rehab")%>%group_by(CLIENT_ID)%>%dplyr::arrange(CLIENT_ID,START_DATE)%>%dplyr::mutate(I=1,n_attempt=cumsum(I))
REF_LC <- service %>% filter(PRODUCT_NAME=="P1 Referral to Life Change")%>%group_by(CLIENT_ID)%>%distinct(SI_ID, .keep_all=TRUE)%>%arrange(CLIENT_ID,START_DATE)%>%dplyr::mutate(tot=n())

GRAD_ADD1 <-program %>% filter(REASON_FOR_LEAVING=="Graduation Exit" & PROG_NAME=="Addiction Rehab")%>%distinct(CLIENT_ID)
GRAD_LC1 <-program %>% filter(REASON_FOR_LEAVING=="Graduation Exit" & PROG_NAME=="Life change")%>%distinct(CLIENT_ID)

GRAD_ADD2 <-service %>% filter(PRODUCT_NAME=="P1 1/2 Addiction rehab graduation")%>%distinct(CLIENT_ID)
GRAD_LC2 <-service %>% filter(PRODUCT_NAME=="P2 Exit Interview")%>%distinct(CLIENT_ID)

#grad1 union grad2
GRAD_ADD <- dplyr::union(GRAD_ADD1,GRAD_ADD2)
GRAD_LC <- dplyr::union(GRAD_LC1,GRAD_LC2)

GRAD_ADD_I <- dplyr::intersect(GRAD_ADD1,GRAD_ADD2)
GRAD_LC_I <- dplyr::intersect(GRAD_LC1,GRAD_LC2)
which(GRAD_ADD1 %in% GRAD_ADD2)
all(GRAD_ADD2 %in% GRAD_ADD1)
all(GRAD_LC1 %in% GRAD_LC2)
all(GRAD_LC2 %in% GRAD_LC1)

all(GRAD_ADD1 %in% GRAD_ADD2)
all(GRAD_ADD2 %in% GRAD_ADD1)
all(GRAD_LC1 %in% GRAD_LC2)
all(GRAD_LC2 %in% GRAD_LC1)
```

### Data / outcome consistency

<!--Check data consistency-->
```{r eval = FALSE}

#Create more program variables

p1 <- program %>% group_by(CLIENT_ID, PROG_NAME)%>% distinct(PA_ID, .keep_all=TRUE)
cast1 <- dcast(p1, CLIENT_ID ~ PROG_NAME, length, value.var="PA_ID")
names(cast1) <- c("CLIENT_ID","ADDICTION_REHAB","LIFE_CHANGE")
x <- list(title = "Number of entries to program")
y <- list(title = "Frequency")
p <- plot_ly(alpha=0.6) %>%
    add_histogram(x=~cast1$ADDICTION_REHAB, name="Addiction rehab",fill = 'tozeroy',color=I("lightblue"))%>%
  add_histogram(x=~cast1$LIFE_CHANGE, name="Life change",fill = 'tozeroy',color=I("lightgreen"))%>%
  layout(barmode="overlay",xaxis=x,yaxis=y)
p
# p2<- left_join(p1, last_seen[,-3],by="CLIENT_ID")
# p3 <-p2 %>% group_by(PA_ID) %>% mutate(REF=ifelse(PROGRAM_ID=="a1o13000001x8opAAA",ifelse(CLIENT_ID %in% REF_LC$CLIENT_ID,1,0),ifelse(CLIENT_ID %in% REF_ADD$CLIENT_ID,1,0)),T1=ifelse(REF==0,NA,))

```

### More stuff 

- Relapse=="P2 Referral to 1st Phase"
- Check for data consistency
- Identify clients "still enrolled"-> possibly lost to follow up?

```{r eval = TRUE}

x <- list(title = "Year")
y <- list(title = "Frequency")

temp<-dcast(program, YEAR ~ REASON_FOR_LEAVING, length, value.var="PA_ID")
  colnames(temp) <- c("YEAR","AWOL","GRAD","RESIGNED","ENROLLED")

p <- plot_ly(temp, x=~YEAR, y=~AWOL, colors="Spectral",type="bar",name="AWOL",alpha=0.2) %>%
  add_trace(y = ~GRAD,name="Graduation") %>%
  add_trace(y = ~RESIGNED,name="Resigned before completion") %>%
    add_trace(y = ~ENROLLED,name="Still enrolled in program") %>%
  layout(xaxis = x, yaxis = y, barmode = 'stack')
p
```



